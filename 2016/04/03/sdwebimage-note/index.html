<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>SDWebImage note</title>
	
	<meta name="description" content="">
	<meta name="image" content="favicon.ico">
	
	<meta itemprop="name" content="SDWebImage note">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="favicon.ico">
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="SDWebImage note">
	<meta name="twitter:description" content="">
	<meta name="twitter:site" content="@everettjf">
	<meta name="twitter:creator" content="@everettjf">
	<meta name="twitter:image:src" content="favicon.ico">
	
	
	<meta name="og:title" content="SDWebImage note">
	<meta name="og:description" content="">
	<meta name="og:image" content="http://everettjf.com/favicon.ico">
	<meta name="og:url" content="http://everettjf.com/2016/04/03/sdwebimage-note/">
	<meta name="og:site_name" content="SDWebImage note">
	<meta name="og:type" content="article">
	
	<meta name="article:author" content="everettjf">
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="/css/style.css">
	<script src="/js/caption.js"></script>

	<link rel="icon" href="/favicon.ico" type="image/x-icon">  
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">  

	
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111349332-1"></script>
	<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());

	gtag('config', 'UA-111349332-1');
	</script>

</head>

<body>

<header>
	<a href="/">/posts</a>
	
		
		&nbsp;&nbsp;·&nbsp;<a href="/about/" style="color:black;">/about</a>
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	


</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
    	el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
    <h1>SDWebImage note <aside></aside></h1>

    <p>
    <nav id="TableOfContents">
<ul>
<li><a href="#basic-information">Basic Information</a></li>
<li><a href="#global-note">Global Note</a></li>
<li><a href="#file-notes">File Notes</a>
<ul>
<li><a href="#0-sdwebimagecompat-h">0. SDWebImageCompat.h</a></li>
<li><a href="#1-sdwebimagedownloader-m">1. SDWebImageDownloader.m</a></li>
<li><a href="#2-sdwebimagedownloader-m">2. SDWebImageDownloader.m</a></li>
<li><a href="#3-sdwebimagedownloader-m">3. SDWebImageDownloader.m</a></li>
<li><a href="#4-sdwebimagedownloader-m">4. SDWebImageDownloader.m</a></li>
<li><a href="#5-sdwebimagedownloader-m">5. SDWebImageDownloader.m</a></li>
<li><a href="#6-sdwebimagedownloader-m">6. SDWebImageDownloader.m</a></li>
<li><a href="#7-sdwebimagedownloader-m">7. SDWebImageDownloader.m</a></li>
<li><a href="#8-sdwebimagedownloaderoperation-m">8. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#9-sdwebimagedownloaderoperation-m">9. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#10-sdwebimagedownloaderoperation-m">10. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#11-sdwebimagedownloaderoperation-m">11. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#12-sdwebimagedownloaderoperation-m">12. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#13-sdwebimagedownloaderoperation-m">13. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#14-sdwebimagedownloaderoperation-m">14. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#15-sdwebimagedownloaderoperation-m">15. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#16-sdwebimagedownloaderoperation-m">16. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#17-sdwebimagedownloaderoperation-m">17. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#18-sdwebimagedownloaderoperation-m">18. SDWebImageDownloaderOperation.m</a></li>
<li><a href="#19-sdimagecache-m">19. SDImageCache.m</a></li>
<li><a href="#20-sdimagecache-m">20. SDImageCache.m</a></li>
<li><a href="#21-sdimagecache-m">21. SDImageCache.m</a></li>
<li><a href="#22-sdimagecache-m">22. SDImageCache.m</a></li>
<li><a href="#23-sdimagecache-m">23. SDImageCache.m</a></li>
<li><a href="#24-sdimagecache-m">24. SDImageCache.m</a></li>
<li><a href="#25-sdimagecache-m">25. SDImageCache.m</a></li>
<li><a href="#26-sdimagecache-m">26. SDImageCache.m</a></li>
<li><a href="#27-sdimagecache-m">27. SDImageCache.m</a></li>
<li><a href="#28-sdwebimagecompat-m">28. SDWebImageCompat.m</a></li>
<li><a href="#29-nsdata-imagecontenttype-m">29. NSData+ImageContentType.m</a></li>
<li><a href="#30-uiimage-gif-m">30. UIImage+GIF.m</a></li>
<li><a href="#31-sdwebimagedecoder-m">31. SDWebImageDecoder.m</a></li>
<li><a href="#32-sdimagecache-m">32. SDImageCache.m</a></li>
<li><a href="#33-nsfilemanager-h">33. NSFileManager.h</a></li>
<li><a href="#34-nsdictionary-h">34. NSDictionary.h</a></li>
<li><a href="#35-sdwebimagemanager-m">35. SDWebImageManager.m</a></li>
<li><a href="#36-sdwebimagemanager-m">36. SDWebImageManager.m</a></li>
<li><a href="#37-sdwebimagemanager-m">37. SDWebImageManager.m</a></li>
<li><a href="#38-uiimage-multiformat-m">38. UIImage+MultiFormat.m</a></li>
<li><a href="#39-uiview-webcacheoperation-m">39. UIView+WebCacheOperation.m</a></li>
<li><a href="#40-uiview-webcacheoperation-m">40. UIView+WebCacheOperation.m</a></li>
<li><a href="#41-uiimageview-webcache-m">41. UIImageView+WebCache.m</a></li>
<li><a href="#42-uiimageview-webcache-m">42. UIImageView+WebCache.m</a></li>
</ul></li>
<li><a href="#summarize">Summarize</a></li>
</ul>
</nav>
    </p>

    <hr/>
    <p>&nbsp;</p>

    

<h1 id="basic-information">Basic Information</h1>

<ul>
<li>Name : SDWebImage</li>
<li>Site : <a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></li>
<li>Repo : <a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></li>
<li>Revision : 0da78a4ce6485d8d4c23d348d355fabad7c227f3</li>
<li>Description :
经典的、异步下载图片的、带缓存的库</li>
</ul>

<h1 id="global-note">Global Note</h1>

<h1 id="file-notes">File Notes</h1>

<h2 id="0-sdwebimagecompat-h">0. SDWebImageCompat.h</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageCompat.h</li>
<li>Line : 60 - 72</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">#define dispatch_main_sync_safe(block)\
    if ([NSThread isMainThread]) {\
        block();\
    } else {\
        dispatch_sync(dispatch_get_main_queue(), block);\
    }

#define dispatch_main_async_safe(block)\
    if ([NSThread isMainThread]) {\
        block();\
    } else {\
        dispatch_async(dispatch_get_main_queue(), block);\
    }
</code></pre>

<p>方便的dispatch_main 保证主线程运行</p>

<h2 id="1-sdwebimagedownloader-m">1. SDWebImageDownloader.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloader.m</li>
<li>Line : 33 - 33</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">    if (NSClassFromString(@&quot;SDNetworkActivityIndicator&quot;)) {
</code></pre>

<p>判断某个类是否存在</p>

<h2 id="2-sdwebimagedownloader-m">2. SDWebImageDownloader.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloader.m</li>
<li>Line : 35 - 38</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;
        id activityIndicator = [NSClassFromString(@&quot;SDNetworkActivityIndicator&quot;) performSelector:NSSelectorFromString(@&quot;sharedActivityIndicator&quot;)];
#pragma clang diagnostic pop
</code></pre>

<p>动态调用单例方法</p>

<h2 id="3-sdwebimagedownloader-m">3. SDWebImageDownloader.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloader.m</li>
<li>Line : 67 - 68</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        _downloadQueue = [NSOperationQueue new];
        _downloadQueue.maxConcurrentOperationCount = 6;
</code></pre>

<p>NSOperation相比GCD的优势，可配置并行最大线程数</p>

<h2 id="4-sdwebimagedownloader-m">4. SDWebImageDownloader.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloader.m</li>
<li>Line : 111 - 113</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">- (void)setOperationClass:(Class)operationClass {
    _operationClass = operationClass ?: [SDWebImageDownloaderOperation class];
}
</code></pre>

<p>这么动态配置执行的Class。</p>

<h2 id="5-sdwebimagedownloader-m">5. SDWebImageDownloader.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloader.m</li>
<li>Line : 207 - 207</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">    dispatch_barrier_sync(self.barrierQueue, ^{
</code></pre>

<pre><code>    _barrierQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderBarrierQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre>

<p>在并行queue中的很方便的同步方法。</p>

<h2 id="6-sdwebimagedownloader-m">6. SDWebImageDownloader.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloader.m</li>
<li>Line : 214 - 224</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        // Handle single download of simultaneous download request for the same URL
        NSMutableArray *callbacksForURL = self.URLCallbacks[url];
        NSMutableDictionary *callbacks = [NSMutableDictionary new];
        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
        [callbacksForURL addObject:callbacks];
        self.URLCallbacks[url] = callbacksForURL;

        if (first) {
            createCallback();
        }
</code></pre>

<p>每个URL对应多个回调地址。可能同时多次请求相同URL地址，避免重复下载。</p>

<h2 id="7-sdwebimagedownloader-m">7. SDWebImageDownloader.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloader.m</li>
<li>Line : 187 - 192</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        [wself.downloadQueue addOperation:operation];
        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
            // Emulate LIFO execution order by systematically adding new operations as last operation's dependency
            [wself.lastAddedOperation addDependency:operation];
            wself.lastAddedOperation = operation;
        }
</code></pre>

<p>启动下载。如果是Last In First Out，则把最后一个添加的任务的依赖设置为当前要添加的任务。</p>

<h2 id="8-sdwebimagedownloaderoperation-m">8. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 33 - 33</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundTaskId;
</code></pre>

<p>后台任务ID</p>

<h2 id="9-sdwebimagedownloaderoperation-m">9. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 77 - 92</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);
        BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];
        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) {
            __weak __typeof__ (self) wself = self;
            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];
            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^{
                __strong __typeof (wself) sself = wself;

                if (sself) {
                    [sself cancel];

                    [app endBackgroundTask:sself.backgroundTaskId];
                    sself.backgroundTaskId = UIBackgroundTaskInvalid;
                }
            }];
        }
</code></pre>

<p>后台，保证任务取消</p>

<h2 id="10-sdwebimagedownloaderoperation-m">10. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 96 - 96</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];
</code></pre>

<p>发起下载操作的NSURLConnection</p>

<h2 id="11-sdwebimagedownloaderoperation-m">11. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 100 - 123</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">    [self.connection start];

    if (self.connection) {
        if (self.progressBlock) {
            self.progressBlock(0, NSURLResponseUnknownLength);
        }
        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];
        });

        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) {
            // Make sure to run the runloop in our background thread so it can process downloaded data
            // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5
            //       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);
        }
        else {
            CFRunLoopRun();
        }

        if (!self.isFinished) {
            [self.connection cancel];
            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@{NSURLErrorFailingURLErrorKey : self.request.URL}]];
        }
</code></pre>

<p>发起下载。NSRunLoopRun()  启动后台线程的runloop。NSURLConnection 依赖RunLoop。</p>

<p>SDWebImage是个古老的库，兼容iOS5.1以下。</p>

<h2 id="12-sdwebimagedownloaderoperation-m">12. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 155 - 167</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">- (void)cancelInternalAndStop {
    if (self.isFinished) return;
    [self cancelInternal];
    CFRunLoopStop(CFRunLoopGetCurrent());
}

- (void)cancelInternal {
    if (self.isFinished) return;
    [super cancel];
    if (self.cancelBlock) self.cancelBlock();

    if (self.connection) {
        [self.connection cancel];
</code></pre>

<p>先cancel Connection，然后停止RunLoop。</p>

<h2 id="13-sdwebimagedownloaderoperation-m">13. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 196 - 200</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">- (void)setFinished:(BOOL)finished {
    [self willChangeValueForKey:@&quot;isFinished&quot;];
    _finished = finished;
    [self didChangeValueForKey:@&quot;isFinished&quot;];
}
</code></pre>

<p>KVO</p>

<h2 id="14-sdwebimagedownloaderoperation-m">14. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 213 - 225</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
    
    //'304 Not Modified' is an exceptional one
    if (![response respondsToSelector:@selector(statusCode)] || ([((NSHTTPURLResponse *)response) statusCode] &lt; 400 &amp;&amp; [((NSHTTPURLResponse *)response) statusCode] != 304)) {
        NSInteger expected = response.expectedContentLength &gt; 0 ? (NSInteger)response.expectedContentLength : 0;
        self.expectedSize = expected;
        if (self.progressBlock) {
            self.progressBlock(0, expected);
        }

        self.imageData = [[NSMutableData alloc] initWithCapacity:expected];
        self.response = response;
</code></pre>

<p>看来有个 304 Not Modified 坑。</p>

<h2 id="15-sdwebimagedownloaderoperation-m">15. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 231 - 239</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        NSUInteger code = [((NSHTTPURLResponse *)response) statusCode];
        
        //This is the case when server returns '304 Not Modified'. It means that remote image is not changed.
        //In case of 304 we need just cancel the operation and return cached image from the cache.
        if (code == 304) {
            [self cancelInternal];
        } else {
            [self.connection cancel];
        }
</code></pre>

<p>304 ,则直接返回缓存中的图片</p>

<h2 id="16-sdwebimagedownloaderoperation-m">16. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 252 - 253</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    [self.imageData appendData:data];
</code></pre>

<p>收到数据。self.imageData 是从didReceiveResponse中开辟。</p>

<h2 id="17-sdwebimagedownloaderoperation-m">17. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 256 - 266</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        // The following code is from http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/
        // Thanks to the author @Nyx0uf

        // Get the total bytes downloaded
        const NSInteger totalSize = self.imageData.length;

        // Update the data source, we must pass ALL the data, not just the new bytes
        CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);

        if (width + height == 0) {
            CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);
</code></pre>

<p>渐进的加载图片……内存中绘制渐进效果的图片</p>

<h2 id="18-sdwebimagedownloaderoperation-m">18. SDWebImageDownloaderOperation.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDownloaderOperation.m</li>
<li>Line : 337 - 358</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">+ (UIImageOrientation)orientationFromPropertyValue:(NSInteger)value {
    switch (value) {
        case 1:
            return UIImageOrientationUp;
        case 3:
            return UIImageOrientationDown;
        case 8:
            return UIImageOrientationLeft;
        case 6:
            return UIImageOrientationRight;
        case 2:
            return UIImageOrientationUpMirrored;
        case 4:
            return UIImageOrientationDownMirrored;
        case 5:
            return UIImageOrientationLeftMirrored;
        case 7:
            return UIImageOrientationRightMirrored;
        default:
            return UIImageOrientationUp;
    }
}
</code></pre>

<p>关于Orientation ，参考这篇文章 <a href="http://feihu.me/blog/2015/how-to-handle-image-orientation-on-iOS/">http://feihu.me/blog/2015/how-to-handle-image-orientation-on-iOS/</a></p>

<h2 id="19-sdimagecache-m">19. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 14 - 35</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">// See https://github.com/rs/SDWebImage/pull/1141 for discussion
@interface AutoPurgeCache : NSCache
@end

@implementation AutoPurgeCache

- (id)init
{
    self = [super init];
    if (self) {
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];
    }
    return self;
}

- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];

}

@end
</code></pre>

<p>内存警告时清空缓存</p>

<h2 id="20-sdimagecache-m">20. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 38 - 53</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">// PNG signature bytes and data (below)
static unsigned char kPNGSignatureBytes[8] = {0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A};
static NSData *kPNGSignatureData = nil;

BOOL ImageDataHasPNGPreffix(NSData *data);

BOOL ImageDataHasPNGPreffix(NSData *data) {
    NSUInteger pngSignatureLength = [kPNGSignatureData length];
    if ([data length] &gt;= pngSignatureLength) {
        if ([[data subdataWithRange:NSMakeRange(0, pngSignatureLength)] isEqualToData:kPNGSignatureData]) {
            return YES;
        }
    }

    return NO;
}
</code></pre>

<p>png文件前缀</p>

<h2 id="21-sdimagecache-m">21. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 55 - 57</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) {
    return image.size.height * image.size.width * image.scale * image.scale;
}
</code></pre>

<p>FOUNDATION_STATIC_INLINE 可以学习用用。
图片的cost计算方式。</p>

<h2 id="22-sdimagecache-m">22. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 77 - 77</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        instance = [self new];
</code></pre>

<p>[self new] 学习了。可以研究下 与[XXXX new]的区别。</p>

<h2 id="23-sdimagecache-m">23. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 105 - 105</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        _memCache = [[AutoPurgeCache alloc] init];
</code></pre>

<p>内存的缓存是NSCache。</p>

<h2 id="24-sdimagecache-m">24. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 125 - 127</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        dispatch_sync(_ioQueue, ^{
            _fileManager = [NSFileManager new];
        });
</code></pre>

<p>ioQueue</p>

<p>_ioQueue = dispatch_queue_create(&ldquo;com.hackemist.SDWebImageCache&rdquo;, DISPATCH_QUEUE_SERIAL);</p>

<h2 id="25-sdimagecache-m">25. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 177 - 189</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">- (NSString *)cachedFileNameForKey:(NSString *)key {
    const char *str = [key UTF8String];
    if (str == NULL) {
        str = &quot;&quot;;
    }
    unsigned char r[CC_MD5_DIGEST_LENGTH];
    CC_MD5(str, (CC_LONG)strlen(str), r);
    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,
                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],
                          r[11], r[12], r[13], r[14], r[15], [[key pathExtension] isEqualToString:@&quot;&quot;] ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, [key pathExtension]]];

    return filename;
}
</code></pre>

<p>磁盘缓存文件名称</p>

<h2 id="26-sdimagecache-m">26. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 213 - 238</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">            if (image &amp;&amp; (recalculate || !data)) {
#if TARGET_OS_IPHONE
                // We need to determine if the image is a PNG or a JPEG
                // PNGs are easier to detect because they have a unique signature (http://www.w3.org/TR/PNG-Structure.html)
                // The first eight bytes of a PNG file always contain the following (decimal) values:
                // 137 80 78 71 13 10 26 10

                // If the imageData is nil (i.e. if trying to save a UIImage directly or the image was transformed on download)
                // and the image has an alpha channel, we will consider it PNG to avoid losing the transparency
                int alphaInfo = CGImageGetAlphaInfo(image.CGImage);
                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||
                                  alphaInfo == kCGImageAlphaNoneSkipFirst ||
                                  alphaInfo == kCGImageAlphaNoneSkipLast);
                BOOL imageIsPng = hasAlpha;

                // But if we have an image data, we will look at the preffix
                if ([imageData length] &gt;= [kPNGSignatureData length]) {
                    imageIsPng = ImageDataHasPNGPreffix(imageData);
                }

                if (imageIsPng) {
                    data = UIImagePNGRepresentation(image);
                }
                else {
                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);
                }
</code></pre>

<p>磁盘缓存时，且需要recalculate时，判断png。两种方法判断png。</p>

<ul>
<li>是否有透明通道。alpha。</li>
<li>是否有png的格式magic number前缀。</li>
</ul>

<p>PS：如果需要加载gif，这里注意不要recalculate，否则 再次从磁盘加载后就不是gif文件了（变为jpg文件）。</p>

<h2 id="27-sdimagecache-m">27. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 276 - 278</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">    // this is an exception to access the filemanager on another queue than ioQueue, but we are using the shared instance
    // from apple docs on NSFileManager: The methods of the shared NSFileManager object can be called from multiple threads safely.
    exists = [[NSFileManager defaultManager] fileExistsAtPath:[self defaultCachePathForKey:key]];
</code></pre>

<p>sharedManager 线程安全的哦</p>

<h2 id="28-sdwebimagecompat-m">28. SDWebImageCompat.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageCompat.m</li>
<li>Line : 15 - 49</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">inline UIImage *SDScaledImageForKey(NSString *key, UIImage *image) {
    if (!image) {
        return nil;
    }
    
    if ([image.images count] &gt; 0) {
        NSMutableArray *scaledImages = [NSMutableArray array];

        for (UIImage *tempImage in image.images) {
            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];
        }

        return [UIImage animatedImageWithImages:scaledImages duration:image.duration];
    }
    else {
        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) {
            CGFloat scale = [UIScreen mainScreen].scale;
            if (key.length &gt;= 8) {
                NSRange range = [key rangeOfString:@&quot;@2x.&quot;];
                if (range.location != NSNotFound) {
                    scale = 2.0;
                }
                
                range = [key rangeOfString:@&quot;@3x.&quot;];
                if (range.location != NSNotFound) {
                    scale = 3.0;
                }
            }

            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];
            image = scaledImage;
        }
        return image;
    }
}
</code></pre>

<p>缩放图片。本地存储时，存储缩放的图片</p>

<h2 id="29-nsdata-imagecontenttype-m">29. NSData+ImageContentType.m</h2>

<ul>
<li>Path : /SDWebImage/NSData+ImageContentType.m</li>
<li>Line : 11 - 40</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">+ (NSString *)sd_contentTypeForImageData:(NSData *)data {
    uint8_t c;
    [data getBytes:&amp;c length:1];
    switch (c) {
        case 0xFF:
            return @&quot;image/jpeg&quot;;
        case 0x89:
            return @&quot;image/png&quot;;
        case 0x47:
            return @&quot;image/gif&quot;;
        case 0x49:
        case 0x4D:
            return @&quot;image/tiff&quot;;
        case 0x52:
            // R as RIFF for WEBP
            if ([data length] &lt; 12) {
                return nil;
            }

            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];
            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) {
                return @&quot;image/webp&quot;;
            }

            return nil;
    }
    return nil;
}

</code></pre>

<p>从文件头判断图片类型</p>

<h2 id="30-uiimage-gif-m">30. UIImage+GIF.m</h2>

<ul>
<li>Path : /SDWebImage/UIImage+GIF.m</li>
<li>Line : 14 - 57</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">+ (UIImage *)sd_animatedGIFWithData:(NSData *)data {
    if (!data) {
        return nil;
    }

    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);

    size_t count = CGImageSourceGetCount(source);

    UIImage *animatedImage;

    if (count &lt;= 1) {
        animatedImage = [[UIImage alloc] initWithData:data];
    }
    else {
        NSMutableArray *images = [NSMutableArray array];

        NSTimeInterval duration = 0.0f;

        for (size_t i = 0; i &lt; count; i++) {
            CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL);
            if (!image) {
                continue;
            }

            duration += [self sd_frameDurationAtIndex:i source:source];

            [images addObject:[UIImage imageWithCGImage:image scale:[UIScreen mainScreen].scale orientation:UIImageOrientationUp]];

            CGImageRelease(image);
        }

        if (!duration) {
            duration = (1.0f / 10.0f) * count;
        }

        animatedImage = [UIImage animatedImageWithImages:images duration:duration];
    }

    CFRelease(source);

    return animatedImage;
}
</code></pre>

<p>使用CGImageSourceCreateWithData 读取Gif文件</p>

<h2 id="31-sdwebimagedecoder-m">31. SDWebImageDecoder.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageDecoder.m</li>
<li>Line : 15 - 77</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">+ (UIImage *)decodedImageWithImage:(UIImage *)image {
    // while downloading huge amount of images
    // autorelease the bitmap context
    // and all vars to help system to free memory
    // when there are memory warning.
    // on iOS7, do not forget to call
    // [[SDImageCache sharedImageCache] clearMemory];

    if (image == nil) { // Prevent &quot;CGBitmapContextCreateImage: invalid context 0x0&quot; error
        return nil;
    }

    @autoreleasepool{
        // do not decode animated images
        if (image.images) { return image; }
        
        CGImageRef imageRef = image.CGImage;
        
        CGImageAlphaInfo alpha = CGImageGetAlphaInfo(imageRef);
        BOOL anyAlpha = (alpha == kCGImageAlphaFirst ||
                         alpha == kCGImageAlphaLast ||
                         alpha == kCGImageAlphaPremultipliedFirst ||
                         alpha == kCGImageAlphaPremultipliedLast);
        
        if (anyAlpha) { return image; }
        
        // current
        CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef));
        CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef);
        
        bool unsupportedColorSpace = (imageColorSpaceModel == 0 || imageColorSpaceModel == -1 || imageColorSpaceModel == kCGColorSpaceModelCMYK || imageColorSpaceModel == kCGColorSpaceModelIndexed);
        if (unsupportedColorSpace)
            colorspaceRef = CGColorSpaceCreateDeviceRGB();
        
        size_t width = CGImageGetWidth(imageRef);
        size_t height = CGImageGetHeight(imageRef);
        NSUInteger bytesPerPixel = 4;
        NSUInteger bytesPerRow = bytesPerPixel * width;
        NSUInteger bitsPerComponent = 8;
        
        CGContextRef context = CGBitmapContextCreate(NULL,
                                                     width,
                                                     height,
                                                     bitsPerComponent,
                                                     bytesPerRow,
                                                     colorspaceRef,
                                                     kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);
        
        // Draw the image into the context and retrieve the new image, which will now have an alpha layer
        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);
        CGImageRef imageRefWithAlpha = CGBitmapContextCreateImage(context);
        UIImage *imageWithAlpha = [UIImage imageWithCGImage:imageRefWithAlpha scale:image.scale orientation:image.imageOrientation];
        
        if (unsupportedColorSpace)
            CGColorSpaceRelease(colorspaceRef);
        
        CGContextRelease(context);
        CGImageRelease(imageRefWithAlpha);
        
        return imageWithAlpha;
    }
}
</code></pre>

<p>decode image，优化图片加载速度</p>

<h2 id="32-sdimagecache-m">32. SDImageCache.m</h2>

<ul>
<li>Path : /SDWebImage/SDImageCache.m</li>
<li>Line : 506 - 536</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];

        // This enumerator prefetches useful properties for our cache files.
        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL
                                                   includingPropertiesForKeys:resourceKeys
                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles
                                                                 errorHandler:NULL];

        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];
        NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];
        NSUInteger currentCacheSize = 0;

        // Enumerate all of the files in the cache directory.  This loop has two purposes:
        //
        //  1. Removing files that are older than the expiration date.
        //  2. Storing file attributes for the size-based cleanup pass.
        NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];
        for (NSURL *fileURL in fileEnumerator) {
            NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];

            // Skip directories.
            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) {
                continue;
            }

            // Remove files that are older than the expiration date;
            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];
            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) {
                [urlsToDelete addObject:fileURL];
                continue;
            }
</code></pre>

<p>利用文件系统存储文件的时间、大小等元数据来清理文件</p>

<h2 id="33-nsfilemanager-h">33. NSFileManager.h</h2>

<ul>
<li>Path : /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/Foundation.framework/Headers/NSFileManager.h</li>
<li>Line : 442 - 442</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">@interface NSDictionary&lt;KeyType, ObjectType&gt; (NSFileAttributes)
</code></pre>

<p>KeyType 和 ObjectType 。Objective C还有这个语法呀。类似泛型。</p>

<h2 id="34-nsdictionary-h">34. NSDictionary.h</h2>

<ul>
<li>Path : /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Foundation.framework/Headers/NSDictionary.h</li>
<li>Line : 14 - 14</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">@interface NSDictionary&lt;__covariant KeyType, __covariant ObjectType&gt; : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration&gt;
</code></pre>

<p>NSDictionary的声明。泛型中的协变和逆变。</p>

<p>参考这篇文章：<a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/">http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/</a></p>

<p><a href="https://msdn.microsoft.com/zh-cn/library/dd799517.aspx">https://msdn.microsoft.com/zh-cn/library/dd799517.aspx</a></p>

<h2 id="35-sdwebimagemanager-m">35. SDWebImageManager.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageManager.m</li>
<li>Line : 131 - 134</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">    BOOL isFailedUrl = NO;
    @synchronized (self.failedURLs) {
        isFailedUrl = [self.failedURLs containsObject:url];
    }
</code></pre>

<p>存储失败的url</p>

<h2 id="36-sdwebimagemanager-m">36. SDWebImageManager.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageManager.m</li>
<li>Line : 119 - 126</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">    if ([url isKindOfClass:NSString.class]) {
        url = [NSURL URLWithString:(NSString *)url];
    }

    // Prevents app crashing on argument type error like sending NSNull instead of NSURL
    if (![url isKindOfClass:NSURL.class]) {
        url = nil;
    }
</code></pre>

<p>纠正参数类型。判断参数类型。NSNull。</p>

<h2 id="37-sdwebimagemanager-m">37. SDWebImageManager.m</h2>

<ul>
<li>Path : /SDWebImage/SDWebImageManager.m</li>
<li>Line : 305 - 306</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        NSArray *copiedOperations = [self.runningOperations copy];
        [copiedOperations makeObjectsPerformSelector:@selector(cancel)];
</code></pre>

<p>NSArray竟然有这个方法，Objective C真的开发者友好啊。</p>

<h2 id="38-uiimage-multiformat-m">38. UIImage+MultiFormat.m</h2>

<ul>
<li>Path : /SDWebImage/UIImage+MultiFormat.m</li>
<li>Line : 51 - 71</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">+(UIImageOrientation)sd_imageOrientationFromImageData:(NSData *)imageData {
    UIImageOrientation result = UIImageOrientationUp;
    CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)imageData, NULL);
    if (imageSource) {
        CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);
        if (properties) {
            CFTypeRef val;
            int exifOrientation;
            val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);
            if (val) {
                CFNumberGetValue(val, kCFNumberIntType, &amp;exifOrientation);
                result = [self sd_exifOrientationToiOSOrientation:exifOrientation];
            } // else - if it's not set it remains at up
            CFRelease((CFTypeRef) properties);
        } else {
            //NSLog(@&quot;NO PROPERTIES, FAIL&quot;);
        }
        CFRelease(imageSource);
    }
    return result;
}
</code></pre>

<p>从Data获取orientation</p>

<h2 id="39-uiview-webcacheoperation-m">39. UIView+WebCacheOperation.m</h2>

<ul>
<li>Path : /SDWebImage/UIView+WebCacheOperation.m</li>
<li>Line : 16 - 24</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">- (NSMutableDictionary *)operationDictionary {
    NSMutableDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);
    if (operations) {
        return operations;
    }
    operations = [NSMutableDictionary dictionary];
    objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    return operations;
}
</code></pre>

<p>每个UIView关联一个operation集合。（主要用于在Cell重用，或者对UIImageView重复加载url image时，取消之前的加载任务）</p>

<h2 id="40-uiview-webcacheoperation-m">40. UIView+WebCacheOperation.m</h2>

<ul>
<li>Path : /SDWebImage/UIView+WebCacheOperation.m</li>
<li>Line : 43 - 43</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">        } else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)]){
</code></pre>

<p>conformsToProtocol:@protocol
 学习了。</p>

<h2 id="41-uiimageview-webcache-m">41. UIImageView+WebCache.m</h2>

<ul>
<li>Path : /SDWebImage/UIImageView+WebCache.m</li>
<li>Line : 174 - 177</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">- (void)addActivityIndicator {
    if (!self.activityIndicator) {
        self.activityIndicator = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:[self getIndicatorStyle]];
        self.activityIndicator.translatesAutoresizingMaskIntoConstraints = NO;
</code></pre>

<p>看来新版本SDWebImage集成了indicator功能。</p>

<h2 id="42-uiimageview-webcache-m">42. UIImageView+WebCache.m</h2>

<ul>
<li>Path : /SDWebImage/UIImageView+WebCache.m</li>
<li>Line : 44 - 46</li>
<li>Note :</li>
</ul>

<pre><code class="language-c">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock {
    [self sd_cancelCurrentImageLoad];
    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</code></pre>

<p>cancel掉之前对当前imageview的加载操作。</p>

<h1 id="summarize">Summarize</h1>

<hr />

<p><em>Generated by <a href="https://github.com/everettjf/XSourceNote">XSourceNote</a> at 2016-04-03 07:11:39 +0000</em></p>


    
</div>



	<p><small><em>Written April 3, 2016. </em>
		 
		Send feedback to <a  href="https://twitter.com/intent/tweet?text=%40everettjf%20%2320160403sdwebimage-note%20">@everettjf</a>.
		
    </small></p>

	<p>
	<a href="/2016/03/24/uitableview-fdtemplatelayoutcell-note/">← UITableView-FDTemplateLayoutCell note</a>&nbsp;
	<a href="/2016/04/05/yywebimage-note/" style="float:right;">YYWebImage note →</a>
	</p>



<section id="disqus_thread"></section>


<script type="text/javascript">
     
    var disqus_shortname = 'everettjf';

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

     
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



<footer>
	<hr/>
	<p>https://creativecommons.org/licenses/by-nc-sa/2.5/</p>
	<p>This site was made with <a href="https://github.com/gohugoio/hugo">Hugo</a> using theme <a href="https://github.com/schollz/onetwothree">onetwothree</a>.</p>
</footer>
</body>
</html>
