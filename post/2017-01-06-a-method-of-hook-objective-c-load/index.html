<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>A method of hook objective c &#43;load</title>
	
	<meta name="description" content="">
	<meta name="image" content="favicon.ico">
	
	<meta itemprop="name" content="A method of hook objective c &#43;load">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="favicon.ico">
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="A method of hook objective c &#43;load">
	<meta name="twitter:description" content="">
	<meta name="twitter:site" content="@everettjf">
	<meta name="twitter:creator" content="@everettjf">
	<meta name="twitter:image:src" content="favicon.ico">
	
	
	<meta name="og:title" content="A method of hook objective c &#43;load">
	<meta name="og:description" content="">
	<meta name="og:image" content="http://everettjf.com/favicon.ico">
	<meta name="og:url" content="http://everettjf.com/post/2017-01-06-a-method-of-hook-objective-c-load/">
	<meta name="og:site_name" content="A method of hook objective c &#43;load">
	<meta name="og:type" content="article">
	
	<meta name="article:author" content="everettjf">
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="/css/style.css">
	<script src="/js/caption.js"></script>

	<link rel="icon" href="/favicon.ico" type="image/x-icon">  
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">  

	
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111349332-1"></script>
	<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());

	gtag('config', 'UA-111349332-1');
	</script>

</head>

<body>

<header>
	<a href="/">/posts</a>
	
		
		&nbsp;&nbsp;·&nbsp;<a href="/about/" style="color:black;">/about</a>
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	


</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
    	el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
    <h1>A method of hook objective c &#43;load <aside></aside></h1>

    <p>
    <nav id="TableOfContents">
<ul>
<li><a href="#先看objective-c-runtime">先看Objective C Runtime</a></li>
<li><a href="#再看下文档">再看下文档</a></li>
<li><a href="#如何hook">如何hook</a></li>
<li><a href="#代码">代码</a></li>
<li><a href="#如何列出程序所有-load方法">如何列出程序所有+load方法</a></li>
<li><a href="#遗漏">遗漏</a></li>
<li><a href="#timeprofiler">TimeProfiler</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</nav>
    </p>

    <hr/>
    <p>&nbsp;</p>

    

<p>iOS有以下四种方法可方便的在premain阶段执行代码：</p>

<pre><code>1. Objective C类的+load方法
2. C++ static initializer
3. C/C++ __attribute__(constructor) functions 
4. 动态库中的上面三种方法
</code></pre>

<p>所有类的+load方法是在main函数之前、在主线程，以串行方式调用。
因此，任何一个+load方法的耗时大小将直接影响到App的启动耗时。</p>

<h1 id="先看objective-c-runtime">先看Objective C Runtime</h1>

<pre><code>/***********************************************************************
* call_class_loads
* Call all pending class +load methods.
* If new classes become loadable, +load is NOT called for them.
*
* Called only by call_load_methods().
**********************************************************************/
static void call_class_loads(void)
{
    int i;
    
    // Detach current loadable list.
    struct loadable_class *classes = loadable_classes;
    int used = loadable_classes_used;
    loadable_classes = nil;
    loadable_classes_allocated = 0;
    loadable_classes_used = 0;
    
    // Call all +loads for the detached list.
    for (i = 0; i &lt; used; i++) {
        Class cls = classes[i].cls;
        load_method_t load_method = (load_method_t)classes[i].method;
        if (!cls) continue; 

        if (PrintLoading) {
            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());
        }
        (*load_method)(cls, SEL_load);
    }
    
    // Destroy the detached list.
    if (classes) free(classes);
}


</code></pre>

<p>直接通过遍历loadable_classes全局变量，逐个调用。</p>

<p>全局变量的定义如下：</p>

<pre><code>
// List of classes that need +load called (pending superclass +load)
// This list always has superclasses first because of the way it is constructed
static struct loadable_class *loadable_classes = nil;
static int loadable_classes_used = 0;
static int loadable_classes_allocated = 0;

</code></pre>

<h1 id="再看下文档">再看下文档</h1>

<pre><code>The order of initialization is as follows:
- All initializers in any framework you link to.
- All +load methods in your image.
- All C++ static initializers and C/C++ __attribute__(constructor) functions in your image.
- All initializers in frameworks that link to you.
</code></pre>

<h1 id="如何hook">如何hook</h1>

<p>由于+load方法调用时机已经很早，早于 C++ static initializer等，但晚于framework（动态库），那我们就可以把hook的代码写到动态库中，也就可以做到在主程序的 loadable_classes 全局变量初始化之前就把+load hook掉。</p>

<h1 id="代码">代码</h1>

<p>创建一个动态库，使用CaptainHook （<a href="https://github.com/rpetrich/CaptainHook">https://github.com/rpetrich/CaptainHook</a> ，只有一个头文件，使用也很简单）。</p>

<pre><code>#import &quot;CaptainHook.h&quot;


CHDeclareClass(MyClass);
CHClassMethod0(void, MyClass, load){
    CFTimeInterval start = CFAbsoluteTimeGetCurrent();
    
    CHSuper0(MyClass,load);
    
    CFTimeInterval end = CFAbsoluteTimeGetCurrent();
    // output: end - start
}

__attribute__((constructor)) static void entry(){
    NSLog(@&quot;dylib loaded&quot;);
    
    CHLoadLateClass(MyClass);
    CHHook0(MyClass, load);
}
</code></pre>

<p>这样，把这个动态库链接到App主程序，就可以hook主程序中的 MyClass类的+load方法了。</p>

<h1 id="如何列出程序所有-load方法">如何列出程序所有+load方法</h1>

<p>知道了如何Hook，但如何列出所有+load方法呢，代码中搜索太麻烦，那就通过Runtime获取：</p>

<pre><code>
int numClasses;
Class * classes = NULL;
    
classes = NULL;
numClasses = objc_getClassList(NULL, 0);
    
if (numClasses &gt; 0 )
{
   classes = (Class*)malloc(sizeof(Class) * numClasses);
   numClasses = objc_getClassList(classes, numClasses);
   
   for(int idx = 0; idx &lt; numClasses; ++idx){
       Class cls = *(classes + idx);
       
       const char *className = object_getClassName(cls);
       Class metaCls = objc_getMetaClass(className);
       
       BOOL hasLoad = NO;
       unsigned int methodCount = 0;
       Method *methods = class_copyMethodList(metaCls, &amp; methodCount);
       if(methods){
           for(int j = 0; j &lt; methodCount; ++j){
               Method method = *(methods + j);
               SEL name = method_getName(method);
               NSString *methodName = NSStringFromSelector(name);
               if([methodName isEqualToString:@&quot;load&quot;]){
                   hasLoad = YES;
                   break;
               }
           }
       }
       
       if(hasLoad){
           NSLog(@&quot;has load : %@&quot;, NSStringFromClass(cls));
       }else{
//                NSLog(@&quot;not has load : %@&quot;, NSStringFromClass(cls));
       }
   }
   
   free(classes);
}

</code></pre>

<h1 id="遗漏">遗漏</h1>

<p>经过测试发现，如果一个类存在Category，则上面的方法只能hook Category中的+load，多个Category也只能hook一个。还需要研究下如何hook所有的。</p>

<h1 id="timeprofiler">TimeProfiler</h1>

<p>通过TimeProfiler我们也可以进行分析，但经验告诉我们，日常使用中，用户启动App时，耗时经常存在“浮动”，如何把这些“浮动”的代码找出来，就可以用这个方法了。（当然这种hook本身也对性能有影响，个人或者小范围使用，肯定不要发布的。）</p>

<h1 id="总结">总结</h1>

<p>这是一种逐个hook较麻烦的方法，一定有更简单的方法，抽时间研究。</p>


    
</div>



	<p><small><em>Written January 6, 2017. </em>
		 
		Send feedback to <a  href="https://twitter.com/intent/tweet?text=%40everettjf%20%23post2017-01-06-a-method-of-hook-objective-c-load%20">@everettjf</a>.
		
    </small></p>

	<p>
	<a href="/post/2016-12-25-join-ant-financial-3-month-and-summary-for-2016/">← Summary for 2016 and 3 months in Ant Financial</a>&nbsp;
	<a href="/post/2017-02-06-a-method-of-hook-static-initializers/" style="float:right;">A method of hook static initializers →</a>
	</p>



<section id="disqus_thread"></section>


<script type="text/javascript">
     
    var disqus_shortname = 'everettjf';

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

     
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



<footer>
	<hr/>
	<p>https://creativecommons.org/licenses/by-nc-sa/2.5/</p>
	<p>This site was made with <a href="https://github.com/gohugoio/hugo">Hugo</a> using theme <a href="https://github.com/schollz/onetwothree">onetwothree</a>.</p>
</footer>
</body>
</html>
