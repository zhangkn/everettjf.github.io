<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>A method of delay premain code</title>
	
	<meta name="description" content="">
	<meta name="image" content="favicon.ico">
	
	<meta itemprop="name" content="A method of delay premain code">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="favicon.ico">
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="A method of delay premain code">
	<meta name="twitter:description" content="">
	<meta name="twitter:site" content="@everettjf">
	<meta name="twitter:creator" content="@everettjf">
	<meta name="twitter:image:src" content="favicon.ico">
	
	
	<meta name="og:title" content="A method of delay premain code">
	<meta name="og:description" content="">
	<meta name="og:image" content="http://everettjf.com/favicon.ico">
	<meta name="og:url" content="http://everettjf.com/2017/03/06/a-method-of-delay-premain-code/">
	<meta name="og:site_name" content="A method of delay premain code">
	<meta name="og:type" content="article">
	
	<meta name="article:author" content="everettjf">
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="/css/style.css">
	<script src="/js/caption.js"></script>

	<link rel="icon" href="/favicon.ico" type="image/x-icon">  
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">  

	
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111349332-1"></script>
	<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());

	gtag('config', 'UA-111349332-1');
	</script>

</head>

<body>

<header>
	<a href="/">/posts</a>
	
		
		&nbsp;&nbsp;·&nbsp;<a href="/about/" style="color:black;">/about</a>
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	


</header>


<div class="content">
    <h1>A method of delay premain code <aside></aside></h1>

    <p>
    <nav id="TableOfContents">
<ul>
<li><a href="#main函数之前执行的问题">main函数之前执行的问题</a></li>
<li><a href="#如何解决这些问题">如何解决这些问题</a>
<ul>
<li><a href="#想法来源">想法来源</a></li>
<li><a href="#如何应用">如何应用</a></li>
<li><a href="#进一步完善">进一步完善</a></li>
<li><a href="#启动时调用">启动时调用</a></li>
<li><a href="#改造">改造</a></li>
</ul></li>
<li><a href="#动态库">动态库</a></li>
<li><a href="#性能">性能</a></li>
<li><a href="#参考代码">参考代码</a></li>
</ul>
</nav>
    </p>

    <hr/>
    <p>&nbsp;</p>

    

<p>下面三种方法可以让代码在main函数之前执行：</p>

<ol>
<li>All +load methods</li>
<li>All C++ static initializers</li>
<li>All C/C++ <strong>attribute</strong>(constructor) functions</li>
</ol>

<h1 id="main函数之前执行的问题">main函数之前执行的问题</h1>

<ol>
<li>无法Patch</li>
<li>不能审计耗时</li>
<li>调用UIKit相关方法会导致部分类提早初始化</li>
<li>主线程执行，完全阻塞式执行</li>
</ol>

<h1 id="如何解决这些问题">如何解决这些问题</h1>

<p>能否提供一种便捷的方法把main函数之前的代码移植到main函数之后。</p>

<h2 id="想法来源">想法来源</h2>

<p>发现 Facebook 有个新增的段 FBInjectable ，学习这个段的含义可以知道：可以在编译及链接时期把一些数据放到自定义段中，然后程序中获取段的数据。</p>

<p>如果这个数据是字符串，我们可以通过字符串获取类名；如果是函数地址，我们可以直接调用。</p>

<p>（关于 Facebook 的段 FBInjectable 的含义，可以参考文章 <a href="http://everettjf.com/2016/08/20/facebook-explore-section-fbinjectable">http://everettjf.com/2016/08/20/facebook-explore-section-fbinjectable</a> ）</p>

<p>那么如何创建FBInjectable段呢？</p>

<p>可以使用 __attribute((used,section(&ldquo;segmentname,sectionname&rdquo;))) 关键字把某个变量的放入特殊的section中。</p>

<p>（attribute 参考 <a href="http://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html">http://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html</a> ）</p>

<p>例如：</p>

<pre><code>char * kString1 __attribute((used,section(&quot;__DATA,FBInjectable&quot;))) = &quot;string 1&quot;;
char * kString2 __attribute((used,section(&quot;__DATA,FBInjectable&quot;))) = &quot;string 2&quot;;
char * kString3 __attribute((used,section(&quot;__DATA,FBInjectable&quot;))) = &quot;string 3&quot;;
</code></pre>

<p>编译后，可以在程序的 DATA segment下新建 FBInjectable section，并把kString1,kString2,kString3 三个变量的地址作为 FBInjectable section 内容。</p>

<h2 id="如何应用">如何应用</h2>

<p>模仿Facebook的代码，下面这段代码可以把函数地址（varSampleObject的值）的地址放到QWLoadable段中。</p>

<pre><code>typedef void (*QWLoadableFunctionTemplate)();
static void QWLoadableSampleFunction(){
    // Do something
}
static QWLoadableFunctionTemplate varSampleObject __attribute((used, section(&quot;__DATA,QWLoadable&quot;))) = QWLoadableSampleFunction;
</code></pre>

<p>然后主程序在启动时通过getsectiondata获取到QWLoadable的内容，并逐个调用。</p>

<h2 id="进一步完善">进一步完善</h2>

<p>为了能标记每个函数的名字，可以让函数内部传出，如下：</p>

<pre><code>typedef int (*QWLoadableFunctionCallback)(const char *);
typedef void (*QWLoadableFunctionTemplate)(QWLoadableFunctionCallback);

static void QWLoadableSampleFunction(QWLoadableFunctionCallback QWLoadableCallback){
    if(0 != QWLoadableCallback(&quot;SampleObject&quot;)) return;

    // Do something
}

static QWLoadableFunctionTemplate varSampleObject __attribute((used, section(&quot;__DATA,QWLoadable&quot;))) = QWLoadableSampleFunction;

</code></pre>

<p>这样函数通过 QWLoadableCallback 告诉外部自己的“标识”，并给予外部过滤自己（不调用）的能力。</p>

<h2 id="启动时调用">启动时调用</h2>

<pre><code>
static int QWLoadableFunctionCallbackImpl(const char *name){
    // filter by name
    return 0;
}

static void QWLoadableRun(){
    CFTimeInterval loadStart = CFAbsoluteTimeGetCurrent();
    
    Dl_info info;
    int ret = dladdr(QWLoadableRun, &amp;info);
    if(ret == 0){
        // fatal error
    }
    
#ifndef __LP64__
    const struct mach_header *mhp = (struct mach_header*)info.dli_fbase;
    unsigned long size = 0;
    uint32_t *memory = (uint32_t*)getsectiondata(mhp, QWLoadableSegmentName, QWLoadableSectionName, &amp; size);
#else /* defined(__LP64__) */
    const struct mach_header_64 *mhp = (struct mach_header_64*)info.dli_fbase;
    unsigned long size = 0;
    uint64_t *memory = (uint64_t*)getsectiondata(mhp, QWLoadableSegmentName, QWLoadableSectionName, &amp; size);
#endif /* defined(__LP64__) */
    
    CFTimeInterval loadComplete = CFAbsoluteTimeGetCurrent();
    NSLog(@&quot;QWLoadable:loadcost:%@ms&quot;,@(1000.0*(loadComplete-loadStart)));
    if(size == 0){
        NSLog(@&quot;QWLoadable:empty&quot;);
        return;
    }
    
    for(int idx = 0; idx &lt; size/sizeof(void*); ++idx){
        QWLoadableFunctionTemplate func = (QWLoadableFunctionTemplate)memory[idx];
        func(QWLoadableFunctionCallbackImpl);
    }
    
    NSLog(@&quot;QWLoadable:callcost:%@ms&quot;,@(1000.0*(CFAbsoluteTimeGetCurrent()-loadComplete)));
}
</code></pre>

<h2 id="改造">改造</h2>

<p>调用方可以像下面这样，把原来在+load中的代码移植到两个宏（QWLoadableFunctionBegin 和 QWLoadableFunctionEnd）之间。</p>

<pre><code>QWLoadableFunctionBegin(FooObject)
[BarObject userDefinedLoad];
// anything here
QWLoadableFunctionEnd(FooObject)
</code></pre>

<h1 id="动态库">动态库</h1>

<p>动态库是独立的个体，所以需要单独处理动态库中的QWLoadable的段。</p>

<h1 id="性能">性能</h1>

<p>把+load等main函数之前的代码移植到了main函数之后，但也新增了一个读取section的耗时。</p>

<p>经过测试，100个函数地址的读取，在iPhone5的设备上读取不到1ms。新增了这不到1ms的耗时（这1ms也是可审计的），带来了所有启动阶段行为的可审计，以及最重要的Patch能力。</p>

<h1 id="参考代码">参考代码</h1>

<p><a href="https://github.com/everettjf/Yolo/tree/master/LoadableMacro">https://github.com/everettjf/Yolo/tree/master/LoadableMacro</a></p>


    
</div>



	<p><small><em>Written March 6, 2017. </em>
		 
		Send feedback to <a  href="https://twitter.com/intent/tweet?text=%40everettjf%20%2320170306a-method-of-delay-premain-code%20">@everettjf</a>.
		
    </small></p>

	<p>
	<a href="/2017/02/06/a-method-of-hook-static-initializers/">← A method of hook static initializers</a>&nbsp;
	<a href="/2017/03/11/spacemacs-tutorial/" style="float:right;">Spacemacs tutorial →</a>
	</p>



<section id="disqus_thread"></section>


<script type="text/javascript">
     
    var disqus_shortname = 'everettjf';

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

     
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



<footer>
	<hr/>
	<p>https://creativecommons.org/licenses/by-nc-sa/2.5/</p>
	<p>This site was made with <a href="https://github.com/gohugoio/hugo">Hugo</a> using theme <a href="https://github.com/schollz/onetwothree">onetwothree</a>.</p>
</footer>
</body>
</html>
