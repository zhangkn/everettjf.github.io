<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>A method of hook static initializers</title>
	
	<meta name="description" content="">
	<meta name="image" content="favicon.ico">
	
	<meta itemprop="name" content="A method of hook static initializers">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="favicon.ico">
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="A method of hook static initializers">
	<meta name="twitter:description" content="">
	<meta name="twitter:site" content="@everettjf">
	<meta name="twitter:creator" content="@everettjf">
	<meta name="twitter:image:src" content="favicon.ico">
	
	
	<meta name="og:title" content="A method of hook static initializers">
	<meta name="og:description" content="">
	<meta name="og:image" content="http://everettjf.com/favicon.ico">
	<meta name="og:url" content="http://everettjf.com/2017/02/06/a-method-of-hook-static-initializers/">
	<meta name="og:site_name" content="A method of hook static initializers">
	<meta name="og:type" content="article">
	
	<meta name="article:author" content="everettjf">
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="/css/style.css">
	<script src="/js/caption.js"></script>

	<link rel="icon" href="/favicon.ico" type="image/x-icon">  
	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">  

	
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111349332-1"></script>
	<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());

	gtag('config', 'UA-111349332-1');
	</script>

</head>

<body>

<header>
	<a href="/">/posts</a>
	
		
		&nbsp;&nbsp;·&nbsp;<a href="/about/" style="color:black;">/about</a>
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	


</header>


<div class="content">
    <h1>A method of hook static initializers <aside></aside></h1>

    <p>
    <nav id="TableOfContents">
<ul>
<li><a href="#这个section的用途是什么呢">这个section的用途是什么呢？</a></li>
<li><a href="#有哪些方法可以产生initializer">有哪些方法可以产生Initializer？</a>
<ul>
<li><a href="#1-attribute-constructor">1. __attribute((constructor))</a></li>
<li><a href="#2-全局变量的初始化需要执行代码">2. 全局变量的初始化需要执行代码</a></li>
</ul></li>
<li><a href="#为什么要关注这些">为什么要关注这些</a></li>
<li><a href="#再看backtrace">再看backtrace</a></li>
<li><a href="#编译器合并规律">编译器合并规律</a></li>
<li><a href="#如何-hook-先找调用来源">如何 Hook，先找调用来源</a></li>
<li><a href="#想想如何hook">想想如何hook</a></li>
<li><a href="#如何修改mod-init-func数据">如何修改mod_init_func数据</a></li>
<li><a href="#怎么调用原来的initializer">怎么调用原来的Initializer？</a></li>
<li><a href="#aslr">ASLR</a></li>
<li><a href="#浮动的日志出来了-怎么再定位到文件">浮动的日志出来了，怎么再定位到文件？</a></li>
<li><a href="#代码">代码</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</nav>
    </p>

    <hr/>
    <p>&nbsp;</p>

    

<p>先补充：标题中 static initializers 其实应该叫做 <code>C++ static initializers and C/C++ __attribute__(constructor) functions</code>。</p>

<p>使用 MachOView 打开一个MachO文件，多数情况下会看到这个section <code>__mod_init_func</code> 。</p>

<p><img src="/media/15029043382372.jpg" alt="" /></p>

<h1 id="这个section的用途是什么呢">这个section的用途是什么呢？</h1>

<p>从名字大概猜测，module initializer functions，模块初始化函数，大概就是这个意思。</p>

<p>从dyld的源码中可以找到mod_init_func相关字样：</p>

<pre><code>typedef void (*Initializer)(int argc, const char* argv[], const char* envp[], const char* apple[]);

extern const Initializer  inits_start  __asm(&quot;section$start$__DATA$__mod_init_func&quot;);
extern const Initializer  inits_end    __asm(&quot;section$end$__DATA$__mod_init_func&quot;);


static void runDyldInitializers(const struct macho_header* mh, intptr_t slide, int argc, const char* argv[], const char* envp[], const char* apple[])
{
	for (const Initializer* p = &amp;inits_start; p &lt; &amp;inits_end; ++p) {
		(*p)(argc, argv, envp, apple);
	}
}
</code></pre>

<p>注意注意：调试时会发现，dyld并没有通过调用 runDyldInitializers 来执行所有Initializer，而是通过 <code>void ImageLoaderMachO::doModInitFunctions(const LinkContext&amp; context)</code> 来执行的。但上面的代码在首次搜索时，可以让我们对mod_init_func有个大概的印象。</p>

<p>通过其他资料，可以知道有很多途径可以让代码产生对应的一个Initializer。</p>

<h1 id="有哪些方法可以产生initializer">有哪些方法可以产生Initializer？</h1>

<h2 id="1-attribute-constructor">1. __attribute((constructor))</h2>

<pre><code>__attribute__((constructor)) void myentry(){
    NSLog(@&quot;constructor&quot;);
}
</code></pre>

<h2 id="2-全局变量的初始化需要执行代码">2. 全局变量的初始化需要执行代码</h2>

<p>这里主要是对于C++来说（或者Objective C++）源文件扩展名是.cpp .cxx 或.mm 。这里说的全局变量包括static修饰的作用域仅在当前文件的，也包括不被static修饰的。</p>

<p>全局变量的初始化如果涉及以下情况，则会在mod_init_func中产生对应的条目：</p>

<p>（1）需要执行C函数</p>

<pre><code>bool initBar(){
    int i = 0;
    ++i;
    return i == 1;
}

static bool globalBar = initBar();
bool globalBar2 = initBar();
</code></pre>

<p>（2）需要执行C++类的构造函数</p>

<pre><code>class FooObject{
public:
    FooObject(){
        // do somthing
        NSLog(@&quot;in fooobject&quot;);
    }
    
};

static FooObject globalObj = FooObject();
FooObject globalObj2 = FooObject();
</code></pre>

<p>（3）需要构造Objective-C 类</p>

<pre><code>static NSDictionary * dictObject = @{@&quot;one&quot;:@&quot;1&quot;};
NSDictionary * dictObject2 = @{@&quot;one&quot;:@&quot;1&quot;, @&quot;two&quot;:@&quot;2&quot;};
</code></pre>

<p>（4）struct对于C++来说也可以说是一种类</p>

<p>这种代码其实就执行了CGRect的构造函数，很隐蔽呀~防不胜防啊~</p>

<pre><code>CGRect globalRect = CGRectZero;
</code></pre>

<p>（5）间接导致运行函数</p>

<p>下面的代码间接导致了初始化globalArray时运行了description方法。</p>

<pre><code>NSString *description(const char *str){
    return [NSString stringWithFormat:@&quot;hello %s&quot;,str];
}

#define E(str) description(str)


NSString* globalArray[] = {
    E(&quot;hello&quot;),
    E(&quot;hello&quot;),
    E(&quot;hello&quot;),
    E(&quot;hello&quot;),
    E(&quot;hello&quot;),
    E(&quot;hello&quot;),
};

NSString *globalString = E(&quot;world&quot;);
</code></pre>

<p>（6）其他</p>

<p>还有各式各样其他的姿势。</p>

<h1 id="为什么要关注这些">为什么要关注这些</h1>

<p>由于目前iOS App多数都只是在使用静态库，大量第三方或内部C++写的代码需要静态链接，上面这些代码间接增加了主程序在main函数之前的执行时间。</p>

<p>如果是动态库，且是启动阶段加载，那这些代码依然对启动性能有影响。</p>

<h1 id="再看backtrace">再看backtrace</h1>

<p>加断点后backtrace，可以看到dyld的调用堆栈：</p>

<p><img src="/media/15029043722431.jpg" alt="" /></p>

<h1 id="编译器合并规律">编译器合并规律</h1>

<p>同一个文件中的所有initializer会自动产生一个Initializer，类似于把一个文件中的所有初始化工作交给一个新创建的函数。</p>

<p>如果在一个文件中初始化大量的全局变量，可以发现：最终在mod_init_func段中只产生了一项。而且这一项的符号是下面这样：</p>

<pre><code>frame #3: 0x00000001000b8854 ModFuncInitApp`_GLOBAL__sub_I_TestClass.mm + 24 at TestClass.mm:0
</code></pre>

<p>类似于生成了一个 名称是 <code>_GLOBAL__sub_I_TestClass.mm</code> 的函数。</p>

<h1 id="如何-hook-先找调用来源">如何 Hook，先找调用来源</h1>

<p>先看调用来源，</p>

<pre><code>(lldb) bt
* thread #1: tid = 0x47250, 0x00000001000b87c8 ModFuncInitApp`FooObject::FooObject(this=0x00000001000bd2d8) + 20 at TestClass.mm:15, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  * frame #0: 0x00000001000b87c8 ModFuncInitApp`FooObject::FooObject(this=0x00000001000bd2d8) + 20 at TestClass.mm:15
    frame #1: 0x00000001000b879c ModFuncInitApp`FooObject::FooObject(this=0x00000001000bd2d8) + 28 at TestClass.mm:13
    frame #2: 0x00000001000b8804 ModFuncInitApp`::__cxx_global_var_init() + 24 at TestClass.mm:20
    frame #3: 0x00000001000b8854 ModFuncInitApp`_GLOBAL__sub_I_TestClass.mm + 24 at TestClass.mm:0
    frame #4: 0x00000001000b93e8 ModFuncInitApp`myInitFunc_Initializer(argc=1, argv=0x000000016fd4bab8, envp=0x000000016fd4bac8, apple=0x000000016fd4bb48, vars=0x00000001001d9918) + 140 at hook_cpp_init.mm:64
    frame #5: 0x00000001001bd95c dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 372
    frame #6: 0x00000001001bdb84 dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 36
    frame #7: 0x00000001001b8f2c dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 368
    frame #8: 0x00000001001b7f50 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 140
    frame #9: 0x00000001001b8004 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 84
    frame #10: 0x00000001001aa488 dyld`dyld::initializeMainExecutable() + 220
    frame #11: 0x00000001001ae8f4 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3892
    frame #12: 0x00000001001a9044 dyld`_dyld_start + 68
</code></pre>

<p>通过堆栈，能看到 dyld 的 doModInitFunctions 会调用每个文件中的Initializer。从dyld的源码中找到这个函数：</p>

<pre><code>void ImageLoaderMachO::doModInitFunctions(const LinkContext&amp; context)
{
	if ( fHasInitializers ) {
		const uint32_t cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;
		const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)];
		const struct load_command* cmd = cmds;
		for (uint32_t i = 0; i &lt; cmd_count; ++i) {
			if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) {
				const struct macho_segment_command* seg = (struct macho_segment_command*)cmd;
				const struct macho_section* const sectionsStart = (struct macho_section*)((char*)seg + sizeof(struct macho_segment_command));
				const struct macho_section* const sectionsEnd = &amp;sectionsStart[seg-&gt;nsects];
				for (const struct macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) {
					const uint8_t type = sect-&gt;flags &amp; SECTION_TYPE;
					if ( type == S_MOD_INIT_FUNC_POINTERS ) {
						Initializer* inits = (Initializer*)(sect-&gt;addr + fSlide);
						const size_t count = sect-&gt;size / sizeof(uintptr_t);
						for (size_t i=0; i &lt; count; ++i) {
							Initializer func = inits[i];
							// &lt;rdar://problem/8543820&amp;9228031&gt; verify initializers are in image
							if ( ! this-&gt;containsAddress((void*)func) ) {
								dyld::throwf(&quot;initializer function %p not in mapped image for %s\n&quot;, func, this-&gt;getPath());
							}
							if ( context.verboseInit )
								dyld::log(&quot;dyld: calling initializer function %p in %s\n&quot;, func, this-&gt;getPath());
							func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);
						}
					}
				}
			}
			cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);
		}
	}
}
</code></pre>

<p>注意看这三句：</p>

<pre><code>Initializer* inits = (Initializer*)(sect-&gt;addr + fSlide);
Initializer func = inits[i];
func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);

</code></pre>

<p>可以看到mod_init_func中的每一项，都作为一个函数地址调用，函数类型是 Initializer。那我们找到 Initializer 的原型：</p>

<pre><code>	typedef void (*Initializer)(int argc, const char* argv[], const char* envp[], const char* apple[], const ProgramVars* vars);
</code></pre>

<h1 id="想想如何hook">想想如何hook</h1>

<p>既然mod_init_func中的每个地址都是一个函数地址，且原型也都是一样的。那我们就想办法把mod_init_func中的所有地址都替换为我们自己的函数地址。</p>

<p>先定义一个自己的函数：</p>

<pre><code>void myInitFunc_Initializer(int argc, const char* argv[], const char* envp[], const char* apple[], const struct MyProgramVars* vars){
    printf(&quot;my init func\n&quot;);

}
</code></pre>

<p>那么问题来了，如何让dyld在读取mod_init_func中的数据时，读到的是我们自己的myInitFunc_Initializer呢？</p>

<p>（1）首先，注意到 <code>__mod_init_func section</code> 位于 <code>__DATA segment</code>。__DATA segment是数据段，是可以在运行时修改的。
<img src="/media/15029047838257.jpg" alt="" /></p>

<p>（2）其次，就是找个时机，要早于dyld读取这些Initializer。</p>

<p>平时在使用Objective C的+load方法时，注意到文档这么写：</p>

<pre><code>The order of initialization is as follows:

- All initializers in any framework you link to.
- All +load methods in your image.
- All C++ static initializers and C/C++ __attribute__(constructor) functions in your image.
- All initializers in frameworks that link to you.
</code></pre>

<p><code>+load methods</code> 竟然要更早。那就好办了。在任意一个+load方法中找到进程加载后，mod_init_func段在内存中的地址，把数据都改为 myInitFunc_Initializer 的地址。</p>

<h1 id="如何修改mod-init-func数据">如何修改mod_init_func数据</h1>

<p>使用 getsectiondata 函数可以获取mod_init_func段的内存地址，直接修改就行了。</p>

<p>代码如下：</p>

<pre><code>#ifndef __LP64__
    typedef uint32_t MemoryType;
#else /* defined(__LP64__) */
    typedef uint64_t MemoryType;
#endif /* defined(__LP64__) */

    Dl_info info;
    dladdr((const void *)hookModInitFunc, &amp;info);
    
#ifndef __LP64__
    const struct mach_header *mhp = (struct mach_header*)info.dli_fbase;
    unsigned long size = 0;
    MemoryType *memory = (uint32_t*)getsectiondata(mhp, &quot;__DATA&quot;, &quot;__mod_init_func&quot;, &amp; size);
#else /* defined(__LP64__) */
    const struct mach_header_64 *mhp = (struct mach_header_64*)info.dli_fbase;
    unsigned long size = 0;
    MemoryType *memory = (uint64_t*)getsectiondata(mhp, &quot;__DATA&quot;, &quot;__mod_init_func&quot;, &amp; size);
#endif /* defined(__LP64__) */
    for(int idx = 0; idx &lt; size/sizeof(void*); ++idx){
        MemoryType original_ptr = memory[idx];
        // 这里可以保存原来的地址
        
        memory[idx] = (MemoryType)myInitFunc_Initializer; // 替换为我们自己的Initializer
    }
</code></pre>

<h1 id="怎么调用原来的initializer">怎么调用原来的Initializer？</h1>

<p>想来想去，没想到办法给myInitFunc_Initializer增加记录对应的原函数地址的方法。突然一想，不用管调用顺序，把所有的原函数地址记录下来，然后每调用一次 myInitFunc_Initializer 就逐个调用原函数就行了。</p>

<p>还是看代码吧。</p>

<pre><code>static std::vector&lt;MemoryType&gt; *g_initializer; // 记录每一个原函数地址
static int g_cur_index;
</code></pre>

<p>然后，在自己的Initializer中逐个获取每一个原函数地址，调用并计算耗时。</p>

<pre><code>
typedef void (*OriginalInitializer)(int argc, const char* argv[], const char* envp[], const char* apple[], const MyProgramVars* vars);

void myInitFunc_Initializer(int argc, const char* argv[], const char* envp[], const char* apple[], const struct MyProgramVars* vars){
    printf(&quot;my init func\n&quot;);
    
    ++g_cur_index;
    OriginalInitializer func = (OriginalInitializer)g_initializer-&gt;at(g_cur_index);
    
    CFTimeInterval start = CFAbsoluteTimeGetCurrent();
    
    func(argc,argv,envp,apple,vars);
    
    CFTimeInterval end = CFAbsoluteTimeGetCurrent();
}
</code></pre>

<h1 id="aslr">ASLR</h1>

<p>由于ASLR的存在，不能只记录函数的地址，还需要记录ASLR的地址。用于后续通过符号文件定位出函数地址。</p>

<p>ASLR偏移（准确的说是，ASLR偏移后的基地址，感谢 <a href="http://www.jianshu.com/u/9c51a213b02e">Joy__</a>指出）就是上面代码中的变量 <code>mhp</code>（也就是 mach_header_64 的dli_fbase）。</p>

<h1 id="浮动的日志出来了-怎么再定位到文件">浮动的日志出来了，怎么再定位到文件？</h1>

<p>有了符号文件，把app文件和dsym放在同一个目录下，就可以定位到文件啦。</p>

<pre><code>atos -o Demo.app/Demo 0x100a1a47c -l 0x100018000

_GLOBAL__sub_I_XXXXX.cpp (in Demo) + 1

</code></pre>

<p>详细参考这篇文章</p>

<ul>
<li><a href="http://www.jamiegrove.com/software/fixing-bugs-using-os-x-crash-logs-and-atos-to-symbolicate-and-find-line-numbers">http://www.jamiegrove.com/software/fixing-bugs-using-os-x-crash-logs-and-atos-to-symbolicate-and-find-line-numbers</a>
或者</li>
<li><a href="https://everettjf.github.io/2015/09/09/ios-plcrashreporter#dsym">https://everettjf.github.io/2015/09/09/ios-plcrashreporter#dsym</a></li>
</ul>

<h1 id="代码">代码</h1>

<p><a href="https://github.com/everettjf/Yolo/tree/master/HookCppInitilizers">https://github.com/everettjf/Yolo/tree/master/HookCppInitilizers</a></p>

<h1 id="总结">总结</h1>

<p>定位起来确实麻烦，但使用这个方法能从日志中定位到真实使用App的过程中那些耗时浮动较大的Initializer。</p>

<p>每个Initializer都耗时很少，但长期以来，各种不需要在App启动阶段执行的Initializer都悄无声息的进来了。群众的力量大啊。</p>


    
</div>



	<p><small><em>Written February 6, 2017. </em>
		 
		Send feedback to <a  href="https://twitter.com/intent/tweet?text=%40everettjf%20%2320170206a-method-of-hook-static-initializers%20">@everettjf</a>.
		
    </small></p>

	<p>
	<a href="/2017/01/06/a-method-of-hook-objective-c--load/">← A method of hook objective c &#43;load</a>&nbsp;
	<a href="/2017/03/06/a-method-of-delay-premain-code/" style="float:right;">A method of delay premain code →</a>
	</p>



<section id="disqus_thread"></section>


<script type="text/javascript">
     
    var disqus_shortname = 'everettjf';

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

     
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



<footer>
	<hr/>
	<p>https://creativecommons.org/licenses/by-nc-sa/2.5/</p>
	<p>This site was made with <a href="https://github.com/gohugoio/hugo">Hugo</a> using theme <a href="https://github.com/schollz/onetwothree">onetwothree</a>.</p>
</footer>
</body>
</html>
